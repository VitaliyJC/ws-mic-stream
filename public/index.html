<!DOCTYPE html>
<meta charset="utf-8" />
<title>ESP32 Live Audio</title>
<style>
  body {
    font-family: ui-sans-serif, system-ui;
    padding: 20px;
  }
  .ok {
    color: #0a0;
  }
  .bad {
    color: #a00;
  }
</style>
<h1>ESP32 Live Audio</h1>
<p>
  <button id="play">▶️ Start</button>
  <span id="status">idle</span>
</p>
<p>Буфер: <span id="buf">0</span> фреймов</p>

<script>
  const wsScheme = location.protocol === "https:" ? "wss" : "ws";
  const WS_URL = `${wsScheme}://${location.host}/listen`;
  const SAMPLE_RATE = 16000;
  const FRAME_SAMPLES = 320; // 20 ms
  const START_BUFFER_FRAMES = 6; // ~120 ms перед стартом

  let ctx, node, ws;
  let queued = 0;

  async function start() {
    if (!ctx) {
      ctx = new (window.AudioContext || window.webkitAudioContext)({
        sampleRate: SAMPLE_RATE,
      });
      const workletCode = `
    class PCMPlayer extends AudioWorkletProcessor {
      constructor(options){
        super();
        this.buf = new Int16Array( FRAME_SAMPLES * 200 ); // ~4s запас по 20мс
        this.rd = 0; this.wr = 0; this.len = this.buf.length;
        this.ready = false;
        this.started = false;
        this.port.onmessage = (e)=>{
          if (e.data && e.data.type === 'push'){
            const view = new Int16Array(e.data.payload);
            for (let i=0;i<view.length;i++){
              this.buf[this.wr] = view[i];
              this.wr = (this.wr + 1) % this.len;
              if (this.wr === this.rd) { // переполнение — подвинем чтение
                this.rd = (this.rd + FRAME_SAMPLES) % this.len;
              }
            }
          } else if (e.data && e.data.type === 'startWhen') {
            this.ready = true;
            this.startThreshold = e.data.frames;
          }
        }
      }
      availableFrames(){
        return (this.wr - this.rd + this.len) % this.len / FRAME_SAMPLES;
      }
      process(inputs, outputs, parameters){
        const out = outputs[0][0];
        if (this.ready && !this.started){
          if (this.availableFrames() >= this.startThreshold) this.started = true;
        }
        if (!this.started){
          // тишина до накопления буфера
          out.fill(0);
          return true;
        }
        // читаем 128 float32 семплов на тик
        for (let i=0;i<out.length;i++){
          if (this.rd === this.wr){
            out[i] = 0; // underrun
          } else {
            const s16 = this.buf[this.rd];
            this.rd = (this.rd + 1) % this.len;
            out[i] = Math.max(-1, Math.min(1, s16 / 32768));
          }
        }
        return true;
      }
    }
    registerProcessor('pcm-player', PCMPlayer);
    `;
      const blob = new Blob(
        [`const FRAME_SAMPLES=${FRAME_SAMPLES};\n` + workletCode],
        { type: "application/javascript" }
      );
      await ctx.audioWorklet.addModule(URL.createObjectURL(blob));

      node = new AudioWorkletNode(ctx, "pcm-player", {
        numberOfInputs: 0,
        numberOfOutputs: 1,
        outputChannelCount: [1],
      });
      node.connect(ctx.destination);
      node.port.postMessage({ type: "startWhen", frames: START_BUFFER_FRAMES });
    }

    if (!ws || ws.readyState !== WebSocket.OPEN) {
      ws = new WebSocket(WS_URL);
      ws.binaryType = "arraybuffer";
      ws.onopen = () => {
        document.getElementById("status").textContent = "WS: connected";
        document.getElementById("status").className = "ok";
      };
      ws.onclose = () => {
        document.getElementById("status").textContent = "WS: closed";
        document.getElementById("status").className = "bad";
      };
      ws.onmessage = (ev) => {
        // ожидаем ровно 320 * int16 (640 байт)
        node.port.postMessage({ type: "push", payload: ev.data }, [ev.data]);
        queued++;
        document.getElementById("buf").textContent = queued;
        // слегка «подпускаем пар» у счётчика
        if (queued > 20) queued = 10;
      };
    }

    await ctx.resume();
    document.getElementById(
      "status"
    ).textContent = `AudioContext: ${ctx.state} @ ${ctx.sampleRate} Hz`;
    document.getElementById("status").className = "ok";
  }

  document.getElementById("play").onclick = start;
  document.body.addEventListener("click", () => ctx && ctx.resume());
</script>
