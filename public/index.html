<!DOCTYPE html>
<meta charset="utf-8" />
<title>ESP32 Live Audio</title>
<style>
  body {
    font-family: ui-sans-serif, system-ui;
    padding: 20px;
  }
  .ok {
    color: #0a0;
  }
  .bad {
    color: #a00;
  }
</style>
<h1>ESP32 Live Audio</h1>
<p>
  <button id="play">▶️ Start</button>
  <span id="status">idle</span>
</p>
<p>Буфер: <span id="buf">0</span> фреймов</p>

<script>
  const SAMPLE_RATE = 16000;
  const FRAME_SAMPLES = 320; // 20 ms
  const START_BUFFER_FRAMES = 6; // ~120 ms
  const wsScheme = location.protocol === "https:" ? "wss" : "ws";
  const WS_URL = `${wsScheme}://${location.host}/listen`;

  let ctx,
    ws,
    queued = 0;

  // Кольцевой буфер для обоих путей (Worklet/ScriptProcessor)
  const RING_FRAMES = 200; // ~4s
  const ring = new Int16Array(FRAME_SAMPLES * RING_FRAMES);
  let rd = 0,
    wr = 0,
    ringLen = ring.length;

  function pushPCM(int16Array) {
    for (let i = 0; i < int16Array.length; i++) {
      ring[wr] = int16Array[i];
      wr = (wr + 1) % ringLen;
      if (wr === rd) rd = (rd + FRAME_SAMPLES) % ringLen; // предотвращаем переполнение
    }
  }

  function availableFrames() {
    return ((wr - rd + ringLen) % ringLen) / FRAME_SAMPLES;
  }

  function status(txt, ok) {
    const el = document.getElementById("status");
    el.textContent = txt;
    el.className = ok ? "ok" : "bad";
  }

  async function start() {
    if (!ctx) {
      ctx = new (window.AudioContext || window.webkitAudioContext)({
        sampleRate: SAMPLE_RATE,
      });
    }

    // === Попытка AudioWorklet ===
    if (ctx.audioWorklet) {
      try {
        const code = `
        class PCMPlayer extends AudioWorkletProcessor {
          constructor(){
            super();
            this.FRAME = ${FRAME_SAMPLES};
            this.len = this.FRAME * ${RING_FRAMES};
            this.buf = new Int16Array(this.len);
            this.rd=0; this.wr=0;
            this.started=false;
            this.startFrames=${START_BUFFER_FRAMES};
            this.port.onmessage = (e)=>{
              if (e.data && e.data.type==='push'){
                const v = new Int16Array(e.data.payload);
                for (let i=0;i<v.length;i++){
                  this.buf[this.wr]=v[i];
                  this.wr=(this.wr+1)%this.len;
                  if (this.wr===this.rd) this.rd=(this.rd+this.FRAME)%this.len;
                }
              }
            };
          }
          avail(){ return (this.wr - this.rd + this.len) % this.len / this.FRAME; }
          process(_, outputs){
            const out = outputs[0][0];
            if (!this.started && this.avail() >= this.startFrames) this.started = true;
            for (let i=0;i<out.length;i++){
              if (!this.started || this.rd===this.wr) out[i]=0;
              else {
                const s16 = this.buf[this.rd];
                this.rd = (this.rd + 1) % this.len;
                out[i] = Math.max(-1, Math.min(1, s16 / 32768));
              }
            }
            return true;
          }
        }
        registerProcessor('pcm-player', PCMPlayer);
      `;
        const blob = new Blob([code], { type: "application/javascript" });
        await ctx.audioWorklet.addModule(URL.createObjectURL(blob));
        const node = new AudioWorkletNode(ctx, "pcm-player", {
          numberOfInputs: 0,
          numberOfOutputs: 1,
          outputChannelCount: [1],
        });
        node.connect(ctx.destination);

        // подключаем WS ТОЛЬКО после готовности узла
        await openWS(async (buf) => {
          node.port.postMessage({ type: "push", payload: buf }, [buf]);
        });

        await ctx.resume();
        status(
          `AudioContext: ${ctx.state} @ ${ctx.sampleRate} Hz (worklet)`,
          true
        );
        return;
      } catch (e) {
        console.warn("AudioWorklet failed, fallback to ScriptProcessor", e);
      }
    }

    // === Фоллбек: ScriptProcessorNode ===
    const proc = ctx.createScriptProcessor(1024, 0, 1);
    let started = false;
    proc.onaudioprocess = (ev) => {
      const out = ev.outputBuffer.getChannelData(0);
      if (!started && availableFrames() >= START_BUFFER_FRAMES) started = true;
      for (let i = 0; i < out.length; i++) {
        if (!started || rd === wr) {
          out[i] = 0;
          continue;
        }
        const s16 = ring[rd];
        rd = (rd + 1) % ringLen;
        out[i] = Math.max(-1, Math.min(1, s16 / 32768));
      }
    };
    proc.connect(ctx.destination);

    await openWS(async (buf) => {
      pushPCM(new Int16Array(buf));
    });

    await ctx.resume();
    status(`AudioContext: ${ctx.state} @ ${ctx.sampleRate} Hz (script)`, true);
  }

  // Открытие WS + единая обработка «Blob или ArrayBuffer»
  async function openWS(onFrame) {
    return new Promise((resolve, reject) => {
      if (window.ws && ws.readyState === WebSocket.OPEN) return resolve();
      ws = new WebSocket(WS_URL);
      ws.binaryType = "arraybuffer";
      ws.onopen = () => {
        status("WS: connected", true);
        resolve();
      };
      ws.onclose = () => {
        status("WS: closed", false);
      };
      ws.onerror = (e) => {
        console.error("WS error", e);
      };

      let cnt = 0;
      ws.onmessage = async (ev) => {
        const buf =
          ev.data instanceof Blob ? await ev.data.arrayBuffer() : ev.data;
        onFrame(buf);
        document.getElementById("buf").textContent = ++cnt;
        if (cnt > 20) cnt = 10;
      };
    });
  }

  document.getElementById("play").onclick = start;
  document.body.addEventListener("click", () => ctx && ctx.resume());
</script>
